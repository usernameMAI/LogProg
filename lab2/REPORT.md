#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Зубко Д. В,

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|       20.12  |         5     |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

  Существуют разные методы решения логических задач. Из них можно выделить: метод рассуждений, метод таблиц истинности, метод логических высказываний, метод кругов Эйлера. Метод рассуждений это способ вывода каких-либо утверждений из исходных для получения ответа, без явного использования инструментов алгебры логики. Метод логических высказываний сопоставляет условиям задачи формулы алгебры логики, с которыми затем можно построить таблицу истиности или связать в одну формулу, решаемую или той же таблицей истиности, или другими способами. Эти методы так или иначе задействуют перебор возможных решений.
   Благодаря своему механизму поиска ответа Prolog является хорошим средством для решения логических задач. Перебор является его основной функцией и, для правильно созданной базы и верно расписанных правил, Prolog может сделать перебор, самостоятельно согласуя подобранные связи с поставленными правилами.
   
## Задание

6. Может быть, вы и не поверите, но в одном городке жили два чудака: Чук и Гек. Чук совершенно не мог говорить правду по понедельникам, вторникам и средам, хотя в остальные дни он неизменно был правдив. А Гек врал по вторникам, четвергам и субботам, но в другие дни он говорил только правду. Как-то я повстречал эту неразлучную пару и спросил одного из них: Скажи пожалуйста, как тебя зовут? Тот без малейшего колебания ответил: Чук. А скажи-ка мне, какой сегодня день недели? Вчера было воскресенье,сказал мой собеседник. А завтра будет пятница,- добавил его приятель. Подожди, как же так? изумился я, обращаясь к приятелю моего собеседника.Ты уверен, что говоришь правду? Я всегда говорю правду по средам,- услышал я в ответ. Решив, что больше со мной говорить не о чем, приятели пошли дальше, оставив меня в полном недоумении. Но, подумав, я все-таки сообразил, кто из двух друзей был Чук, а кто Гек. Между прочим, по разговору можно установить и день недели, в который я встретился с ними. Попробуйте сообразить и вы.

## Принцип решения
![image](https://user-images.githubusercontent.com/90476016/142775174-84342b64-c253-4df6-8534-e6daaf167d1d.png)

Задаём дни, когда врут Чук и Гек, а также дни недели.
```
days_lie(chuk, [mon, tue, wed]).
days_lie(gek, [tue, thu, sat]).
days([mon, tue, wed, thu, fri, sat, sun]).
```
Предикат statement1(Name, Prev_day, Next_day, Now_day, TF1) проверяет утверждение первого из них. Так как нам известно, что он представился Чуком, то если он врёт, его настоящее имя Гек. Предикат names(Speaker, Friend) возвращает имя второго чудака, после того, как мы узнали имя первого. statement2(Name, Prev_day, Next_day, Now_day, TF2) определяет, говорит ли правду второй чудак.

```
solve(Speaker, Friend, Day):-
        statement1(Speaker, sun, _, _, TF1), names(Speaker, Friend), statement2(Friend, _, fri, wed, TF2), ans(Speaker, TF1, Friend, TF2, Day).
```
С помощью предикатов now_next и now_prev узнаём день, следующий или предыдущий после текущего соответственно. Предикат lie определяет, врёт ли чудак в указанный день, или возвращает дни, в которые чудак говорит неправду. Поскольку второй чудак говорит два утверждения, statement2 проверяет оба их них. 
```
statement1(Name, Prev_day, _, Now_day, TF1):-
        now_next(Prev_day, Now_day),
        lie(chuk, Now_day),
        Name = gek, TF1 = yes, !;
        Name = chuk, TF1 = no.

statement2(Name, _, Next_day, Now_day, TF2):-
        lie(Name, Now_day),
        TF2 = yes, !;
        now_prev(Next_day, Now_day2),
        lie(Name, Now_day2),
        TF2 = yes, !;
        TF2 = no.
```
```
prev(Now, Prev, [Prev|[Now|_]]):-!.
prev(Now, Prev, [_|T]):-
         prev(Now, Prev, T).

now_prev(mon, sun):-!.
now_prev(Now, Prev):-
        days(X),
        prev(Now, Prev, X).

next(Now, Next, [Now|[Next|_]]):-!.
next(Now, Next, [_|T]):-
        next(Now, Next, T).

now_next(sun, mon):-!.
now_next(Now, Next):-
        days(X),
        next(Now, Next, X).
```
Предикат ans ищет ответ с помощью пересечения множеств дней. В данной задаче оба чудака лгут, а значит ответ -- пересечение дней, когда врут первый и второй чудаки.
```
ans(Name1, Lie1, Name2, Lie2, Day):-
        Lie1 = yes, Lie2 = yes,
        findall(Day1, lie(Name1, Day1), List1),
        findall(Day2, lie(Name2, Day2), List2),
        intersection(List1, List2, Day), !;

        Lie1 = yes, Lie2 = no,
        findall(Day1,lie(Name1, Day1), List1),
        findall(Day2,no_lies(Name2, Day2), List2),
        intersection(List1, List2, Day), !;

        Lie1 = no, Lie2 = yes,
        findall(Day1,no_lies(Name1, Day1), List1),
        findall(Day2,lies(Name2, Day2), List2),
        intersection(List1, List2, Day), !;

        Lie1 = no, Lie2 = no,
        findall(Day1,no_lies(Name1, Day1), List1),
        findall(Day2,no_lies(Name2, Day2), List2),
        intersection(List1, List2, Day), !.

no_lies(Name, Day):-
        lie(Name, List1),
        days(List2),
        subtract(List2, List1, NoDay),
        member(Day, NoDay).

names(chuk, gek).
names(gek, chuk).

lie(Name, Day):-
        days_lie(Name, Days),
        member(Day, Days).
```

## Выводы

Выполнив данную работу, я приобрел навык решения логических задач с использованием языка Prolog. Действительно, Prolog является отличным инструментом для подобной работы благодаря его backtracking`у. Программа находит единственное и непротиворечивое решение, по минимуму используя нелогические средства языка. Prolog ищет решения примерно тем же путем, что и человек, но делает это гораздо быстрее и точнее. Сложность решения данной задачи -- O(n), где n -- количество утверждений, сказанное чудаками.



